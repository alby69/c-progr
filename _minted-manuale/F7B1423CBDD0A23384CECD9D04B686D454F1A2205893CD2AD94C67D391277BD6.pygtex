\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Tutorial: Pointers \PYGZhy{} The Absolute Basics}
\PYG{c+cm}{    ================================================================================}

\PYG{c+cm}{    Welcome to Pointers! This is one of the most powerful and defining features}
\PYG{c+cm}{    of the C language. It can seem intimidating, but let\PYGZsq{}s break it down.}

\PYG{c+cm}{    A pointer is simply a variable that holds a memory address as its value.}
\PYG{c+cm}{    Instead of storing a number like `42` or a character like \PYGZsq{}r\PYGZsq{}, it stores}
\PYG{c+cm}{    the location where another variable lives in the computer\PYGZsq{}s memory.}

\PYG{c+cm}{    This first example shows how to declare a pointer and how to get the}
\PYG{c+cm}{    memory address of a regular variable.}

\PYG{c+cm}{    Concepts Covered:}
\PYG{c+cm}{    \PYGZhy{} Declaring a pointer variable (e.g., `int *my\PYGZus{}pointer;`).}
\PYG{c+cm}{    \PYGZhy{} The \PYGZdq{}address\PYGZhy{}of\PYGZdq{} operator (\PYGZam{}) to get a variable\PYGZsq{}s memory location.}
\PYG{c+cm}{    \PYGZhy{} The \PYGZsq{}\PYGZpc{}p\PYGZsq{} format specifier for printing memory addresses.}
\PYG{c+cm}{*/}

\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{()}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// There are two `\PYGZsh{}include \PYGZlt{}stdio.h\PYGZgt{}` lines in the original file.}
\PYG{+w}{    }\PYG{c+c1}{// While harmless, it\PYGZsq{}s redundant. We only need one.}

\PYG{+w}{    }\PYG{c+c1}{// Declare some regular variables of different types.}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{a}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{42}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{n}{d}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mf}{58.394}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{c}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}r\PYGZsq{}}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{} Declaring and Assigning Pointers \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{+w}{    }\PYG{c+c1}{// This declares a variable named \PYGZsq{}addressOfA\PYGZsq{} that is a \PYGZdq{}pointer to an int\PYGZdq{}.}
\PYG{+w}{    }\PYG{c+c1}{// The asterisk (*) indicates that it\PYGZsq{}s a pointer.}
\PYG{+w}{    }\PYG{c+c1}{// We then use the address\PYGZhy{}of operator (\PYGZam{}) to get the memory address of \PYGZsq{}a\PYGZsq{}}
\PYG{+w}{    }\PYG{c+c1}{// and we assign that address as the value of our pointer.}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{addressOfA}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{a}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// We do the same for the other data types.}
\PYG{+w}{    }\PYG{k+kt}{double}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{addressOfD}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{d}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{addressOfC}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{c}\PYG{p}{;}


\PYG{+w}{    }\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{} Printing Memory Addresses \PYGZhy{}\PYGZhy{}\PYGZhy{}}

\PYG{+w}{    }\PYG{c+c1}{// The `\PYGZpc{}p` format specifier is used with `printf` to print memory addresses}
\PYG{+w}{    }\PYG{c+c1}{// in a standard hexadecimal format.}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The value of \PYGZsq{}a\PYGZsq{} is \PYGZpc{}d, and it is stored at memory address: \PYGZpc{}p}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{a}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{addressOfA}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The value of \PYGZsq{}d\PYGZsq{} is \PYGZpc{}lf, and it is stored at memory address: \PYGZpc{}p}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{d}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{addressOfD}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}The value of \PYGZsq{}c\PYGZsq{} is \PYGZsq{}\PYGZpc{}c\PYGZsq{}, and it is stored at memory address: \PYGZpc{}p}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{c}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{addressOfC}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// You can also print the address directly without using a pointer variable:}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{We can also print the address of \PYGZsq{}a\PYGZsq{} directly: \PYGZpc{}p}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{\PYGZam{}}\PYG{n}{a}\PYG{p}{);}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Further Exploration:}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    1.  What is the value *of the pointer variable itself*? It\PYGZsq{}s a memory address.}
\PYG{c+cm}{        What is the *address of the pointer variable*? A pointer is a variable,}
\PYG{c+cm}{        so it has its own memory address too! You can find it with `\PYGZam{}addressOfA`.}
\PYG{c+cm}{        Try printing it out!}
\PYG{c+cm}{    2.  What is the size of a pointer? Try `printf(\PYGZdq{}\PYGZpc{}zu\PYGZdq{}, sizeof(addressOfA));`.}
\PYG{c+cm}{        Do this for `addressOfD` and `addressOfC` as well. You will likely find}
\PYG{c+cm}{        that all pointers have the same size on your system (typically 4 or 8}
\PYG{c+cm}{        bytes), because they all just store a memory address, regardless of the}
\PYG{c+cm}{        type of data they point to.}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{*/}

\end{Verbatim}
