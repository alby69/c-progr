\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Tutorial: Pointers \PYGZhy{} Pointer Arithmetic}
\PYG{c+cm}{    ================================================================================}

\PYG{c+cm}{    Pointer arithmetic is a powerful feature that allows you to move a pointer}
\PYG{c+cm}{    forwards or backwards in memory. This is especially useful for navigating}
\PYG{c+cm}{    arrays.}

\PYG{c+cm}{    When you add an integer `n` to a pointer, you are not adding `n` bytes to}
\PYG{c+cm}{    the address. Instead, you are moving the pointer forward by `n` *elements*}
\PYG{c+cm}{    of the type it points to. The compiler automatically knows the size of the}
\PYG{c+cm}{    data type (e.g., 4 bytes for an `int`) and does the correct calculation.}

\PYG{c+cm}{    `pointer + n` is equivalent to `address\PYGZus{}of\PYGZus{}pointer + n * sizeof(type)`}

\PYG{c+cm}{    Concepts Covered:}
\PYG{c+cm}{    \PYGZhy{} The equivalence of array names and pointers to the first element.}
\PYG{c+cm}{    \PYGZhy{} Using `*(ptr + n)` to access the nth element.}
\PYG{c+cm}{    \PYGZhy{} Incrementing a pointer (`ptr++`) to move to the next element.}
\PYG{c+cm}{    \PYGZhy{} Modifying a pointer by a larger value (`ptr += 3`).}
\PYG{c+cm}{*/}

\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printArray}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{[],}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{);}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{array}\PYG{p}{[]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{p}{\PYGZob{}}\PYG{l+m+mi}{10}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{20}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{30}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{40}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{50}\PYG{p}{,}\PYG{+w}{ }\PYG{l+m+mi}{60}\PYG{p}{\PYGZcb{};}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{size}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{6}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{ptr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{array}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// ptr now points to the first element (array[0]).}

\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Original array: \PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printArray}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Pointer \PYGZsq{}ptr\PYGZsq{} currently points to address \PYGZpc{}p, which holds the value \PYGZpc{}d.}\PYG{l+s+se}{\PYGZbs{}n\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ptr}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{ptr}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{} Accessing elements using pointer arithmetic \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{// `*(ptr + 2)` accesses the element at index 2 (value 30).}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Accessing element at index 2 using *(ptr + 2): \PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{p}{(}\PYG{n}{ptr}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{));}

\PYG{+w}{    }\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{} Modifying elements using pointer arithmetic \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Modifying element at index 2 to be 33...}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{o}{*}\PYG{p}{(}\PYG{n}{ptr}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{2}\PYG{p}{)}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{33}\PYG{p}{;}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Array after modification: \PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printArray}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{} Moving the pointer itself \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{// `ptr++` moves the pointer to the next element in the array.}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Moving pointer with ptr++...}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{ptr}\PYG{o}{++}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// ptr now points to the second element (array[1]).}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Pointer \PYGZsq{}ptr\PYGZsq{} now points to address \PYGZpc{}p, which holds the value \PYGZpc{}d.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ptr}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{ptr}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Modifying this element to be 22...}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{ptr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{22}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// This changes array[1].}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Array after modification: \PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printArray}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// We can also move the pointer by more than one step.}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Moving pointer with ptr += 3...}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{ptr}\PYG{+w}{ }\PYG{o}{+=}\PYG{+w}{ }\PYG{l+m+mi}{3}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// ptr was at index 1, now it moves to index 1 + 3 = 4.}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Pointer \PYGZsq{}ptr\PYGZsq{} now points to address \PYGZpc{}p, which holds the value \PYGZpc{}d.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{ptr}\PYG{p}{,}\PYG{+w}{ }\PYG{o}{*}\PYG{n}{ptr}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Modifying this element to be 55...}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{o}{*}\PYG{n}{ptr}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{55}\PYG{p}{;}\PYG{+w}{ }\PYG{c+c1}{// This changes array[4].}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Array after modification: \PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printArray}\PYG{p}{(}\PYG{n}{array}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{k+kt}{void}\PYG{+w}{ }\PYG{n+nf}{printArray}\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{[],}\PYG{+w}{ }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{size}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZpc{}d \PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{arr}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Further Exploration:}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    1.  What happens if you try to dereference a pointer that has moved past the}
\PYG{c+cm}{        end of the array (e.g., after `ptr += 3;`, add another `ptr++` and then}
\PYG{c+cm}{        try to print `*ptr`)? This is a dangerous operation that reads from}
\PYG{c+cm}{        memory you don\PYGZsq{}t own, leading to undefined behavior.}
\PYG{c+cm}{    2.  You can also use the subtraction operator. If `ptr` points to `array[4]`,}
\PYG{c+cm}{        what do you think `*(ptr \PYGZhy{} 2)` would give you?}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{*/}

\end{Verbatim}
