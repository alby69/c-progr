\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Tutorial: C Basics \PYGZhy{} The \PYGZsq{}char\PYGZsq{} Data Type}
\PYG{c+cm}{    ================================================================================}

\PYG{c+cm}{    This exercise introduces the \PYGZsq{}char\PYGZsq{} data type, which is used to store}
\PYG{c+cm}{    single characters.}

\PYG{c+cm}{    Concepts Covered:}
\PYG{c+cm}{    \PYGZhy{} The \PYGZsq{}char\PYGZsq{} data type for single characters.}
\PYG{c+cm}{    \PYGZhy{} Character literals, enclosed in single quotes (e.g., \PYGZsq{}A\PYGZsq{}).}
\PYG{c+cm}{    \PYGZhy{} The \PYGZsq{}\PYGZpc{}c\PYGZsq{} format specifier for printing characters.}
\PYG{c+cm}{*/}

\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{c+c1}{// Variable Declaration and Initialization:}
\PYG{+w}{    }\PYG{c+c1}{// We declare three variables of type \PYGZsq{}char\PYGZsq{}.}
\PYG{+w}{    }\PYG{c+c1}{// A \PYGZsq{}char\PYGZsq{} holds a single character value.}
\PYG{+w}{    }\PYG{c+c1}{// Character literals in C are enclosed in single quotes (\PYGZsq{} \PYGZsq{}).}
\PYG{+w}{    }\PYG{c+c1}{// Note the difference: \PYGZsq{}A\PYGZsq{} is a char, while \PYGZdq{}A\PYGZdq{} is a string.}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{letter1}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}i\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{letter2}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}n\PYGZsq{}}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{letter3}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+s+sc}{\PYGZsq{}C\PYGZsq{}}\PYG{p}{;}

\PYG{+w}{    }\PYG{c+c1}{// The \PYGZsq{}\PYGZpc{}c\PYGZsq{} format specifier in printf is used to print a single character.}
\PYG{+w}{    }\PYG{c+c1}{// We provide the char variables as arguments, and they are substituted}
\PYG{+w}{    }\PYG{c+c1}{// for the \PYGZpc{}c placeholders in the output.}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Programming \PYGZpc{}c\PYGZpc{}c \PYGZpc{}c}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{letter1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{letter2}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{letter3}\PYG{p}{);}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Further Exploration:}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    1.  In C, characters are actually stored as small integer values according to}
\PYG{c+cm}{        a standard like ASCII. You can see this by printing a char variable}
\PYG{c+cm}{        using the \PYGZsq{}\PYGZpc{}d\PYGZsq{} (integer) format specifier instead of \PYGZsq{}\PYGZpc{}c\PYGZsq{}.}
\PYG{c+cm}{        Try it: `printf(\PYGZdq{}The ASCII value of \PYGZpc{}c is \PYGZpc{}d\PYGZbs{}n\PYGZdq{}, letter3, letter3);`}
\PYG{c+cm}{    2.  You can also perform arithmetic on char variables. What do you think}
\PYG{c+cm}{        `letter3 + 1` would produce if you print it as a character? Try it out!}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{*/}

\end{Verbatim}
