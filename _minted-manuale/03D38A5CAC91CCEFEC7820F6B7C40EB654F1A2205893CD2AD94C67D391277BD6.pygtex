\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Tutorial: Algorithms \PYGZhy{} Counting Duplicate Characters}
\PYG{c+cm}{    ================================================================================}

\PYG{c+cm}{    This program counts the number of unique characters that are repeated in a word.}
\PYG{c+cm}{    For example, in the word \PYGZdq{}erroneousnesses\PYGZdq{}, the letters \PYGZsq{}e\PYGZsq{}, \PYGZsq{}r\PYGZsq{}, \PYGZsq{}o\PYGZsq{}, and \PYGZsq{}s\PYGZsq{}}
\PYG{c+cm}{    are all repeated, so the program should output 4.}

\PYG{c+cm}{    The algorithm used here is quite clever and demonstrates a powerful technique:}
\PYG{c+cm}{    1.  **Sort:** The characters of the word are sorted alphabetically. This has}
\PYG{c+cm}{        the effect of grouping all identical letters together.}
\PYG{c+cm}{        \PYGZdq{}erroneousnesses\PYGZdq{} \PYGZhy{}\PYGZgt{} \PYGZdq{}eeeennoorrssssu\PYGZdq{}}
\PYG{c+cm}{    2.  **Count Groups:** Iterate through the sorted string and count the number}
\PYG{c+cm}{        of times a new group of duplicate letters begins.}

\PYG{c+cm}{    Concepts Covered:}
\PYG{c+cm}{    \PYGZhy{} Combining sorting and searching to solve a problem.}
\PYG{c+cm}{    \PYGZhy{} Using Bubble Sort on a character array.}
\PYG{c+cm}{    \PYGZhy{} A custom algorithm to count groups of duplicates in a sorted list.}
\PYG{c+cm}{*/}

\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string.h\PYGZgt{}}\PYG{c+c1}{ // For strlen()}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{[}\PYG{l+m+mi}{51}\PYG{p}{];}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{temp\PYGZus{}swap}\PYG{p}{;}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{num\PYGZus{}duplicate\PYGZus{}groups}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}

\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Enter a word to find the number of repeated character types: \PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{scanf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZpc{}s\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{);}

\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{strlen}\PYG{p}{(}\PYG{n}{word}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{} Step 1: Sort the String using Bubble Sort \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{// This arranges the word so all identical letters are adjacent.}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{j}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{n}{j}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{])}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{temp\PYGZus{}swap}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{p}{];}
\PYG{+w}{                }\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{];}
\PYG{+w}{                }\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{temp\PYGZus{}swap}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Sorted word: \PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+c1}{// \PYGZhy{}\PYGZhy{}\PYGZhy{} Step 2: Count the Groups of Duplicates \PYGZhy{}\PYGZhy{}\PYGZhy{}}
\PYG{+w}{    }\PYG{c+c1}{// We iterate up to n\PYGZhy{}1 so we can always check `word[i+1]`.}
\PYG{+w}{    }\PYG{k}{for}\PYG{+w}{ }\PYG{p}{(}\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{;}\PYG{+w}{ }\PYG{n}{i}\PYG{o}{++}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{c+c1}{// If the current character is the same as the next one, we\PYGZsq{}ve found}
\PYG{+w}{        }\PYG{c+c1}{// the beginning of a group of duplicates.}
\PYG{+w}{        }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{])}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{            }\PYG{n}{num\PYGZus{}duplicate\PYGZus{}groups}\PYG{o}{++}\PYG{p}{;}

\PYG{+w}{            }\PYG{c+c1}{// This is a crucial inner loop. Once we\PYGZsq{}ve counted a group (like the}
\PYG{+w}{            }\PYG{c+c1}{// first \PYGZsq{}e\PYGZsq{} in \PYGZsq{}eeeee...\PYGZsq{}), we need to skip past all the other}
\PYG{+w}{            }\PYG{c+c1}{// identical characters in that same group so we don\PYGZsq{}t count it again.}
\PYG{+w}{            }\PYG{k}{while}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{n}{n}\PYG{+w}{ }\PYG{o}{\PYGZhy{}}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{+w}{ }\PYG{o}{\PYGZam{}\PYGZam{}}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{p}{]}\PYG{+w}{ }\PYG{o}{==}\PYG{+w}{ }\PYG{n}{word}\PYG{p}{[}\PYG{n}{i}\PYG{+w}{ }\PYG{o}{+}\PYG{+w}{ }\PYG{l+m+mi}{1}\PYG{p}{])}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{                }\PYG{n}{i}\PYG{o}{++}\PYG{p}{;}
\PYG{+w}{            }\PYG{p}{\PYGZcb{}}
\PYG{+w}{        }\PYG{p}{\PYGZcb{}}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Number of unique characters that are repeated: \PYGZpc{}d}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{num\PYGZus{}duplicate\PYGZus{}groups}\PYG{p}{);}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Further Exploration:}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    1.  This approach is clever but not the most efficient because Bubble Sort is}
\PYG{c+cm}{        slow. A different approach would be to use a frequency array, like we}
\PYG{c+cm}{        saw in the `04\PYGZus{}word\PYGZus{}lengths\PYGZus{}frequency.c` example. You could have an}
\PYG{c+cm}{        array of size 26 (for the English alphabet) and increment the count for}
\PYG{c+cm}{        each letter you see. Afterwards, you would loop through the frequency}
\PYG{c+cm}{        array and count how many elements have a value greater than 1.}
\PYG{c+cm}{    2.  Try that alternative approach! It will be much faster for long strings.}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{*/}

\end{Verbatim}
