\begin{Verbatim}[commandchars=\\\{\}]
\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Tutorial: Strings \PYGZhy{} Comparing Strings Alphabetically}
\PYG{c+cm}{    ================================================================================}

\PYG{c+cm}{    This program compares two words entered by the user to determine their}
\PYG{c+cm}{    alphabetical order.}

\PYG{c+cm}{    The original code implements the comparison logic manually. We will keep}
\PYG{c+cm}{    that as a reference but introduce the standard C library function `strcmp()`}
\PYG{c+cm}{    from `\PYGZlt{}string.h\PYGZgt{}`, which is the correct and standard way to compare strings.}

\PYG{c+cm}{    Concepts Covered:}
\PYG{c+cm}{    \PYGZhy{} The logic of lexicographical (alphabetical) comparison.}
\PYG{c+cm}{    \PYGZhy{} Using the `strcmp()` function to compare strings.}
\PYG{c+cm}{    \PYGZhy{} Interpreting the return value of `strcmp()`.}
\PYG{c+cm}{*/}

\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}stdio.h\PYGZgt{}}
\PYG{c+cp}{\PYGZsh{}include}\PYG{+w}{ }\PYG{c+cpf}{\PYGZlt{}string.h\PYGZgt{}}\PYG{c+c1}{ // For strcmp()}

\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n+nf}{main}\PYG{p}{(}\PYG{k+kt}{void}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{word1}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{];}
\PYG{+w}{    }\PYG{k+kt}{char}\PYG{+w}{ }\PYG{n}{word2}\PYG{p}{[}\PYG{l+m+mi}{50}\PYG{p}{];}

\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Please enter a word: \PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{scanf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZpc{}s\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word1}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}And another word: \PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{n}{scanf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}\PYGZpc{}s\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word2}\PYG{p}{);}

\PYG{+w}{    }\PYG{c+cm}{/*}
\PYG{c+cm}{        Method 1: Manual Comparison (as in the original code)}
\PYG{c+cm}{        This is how comparison works under the hood. The loop finds the first}
\PYG{c+cm}{        character where the two strings differ. The comparison of those two}
\PYG{c+cm}{        characters then determines the alphabetical order of the words.}

\PYG{c+cm}{        int i = 0;}
\PYG{c+cm}{        while (word1[i] != \PYGZsq{}\PYGZbs{}0\PYGZsq{} \PYGZam{}\PYGZam{} word2[i] != \PYGZsq{}\PYGZbs{}0\PYGZsq{} \PYGZam{}\PYGZam{} word1[i] == word2[i]) \PYGZob{}}
\PYG{c+cm}{            i++;}
\PYG{c+cm}{        \PYGZcb{}}
\PYG{c+cm}{        // After the loop, `i` is the index of the first differing character.}
\PYG{c+cm}{        // We can then compare `word1[i]` and `word2[i]`.}
\PYG{c+cm}{    */}

\PYG{+w}{    }\PYG{c+c1}{// Method 2: The Standard Library Function `strcmp()` (Preferred)}
\PYG{+w}{    }\PYG{c+c1}{// The `strcmp()` function (short for \PYGZdq{}string compare\PYGZdq{}) does all the}
\PYG{+w}{    }\PYG{c+c1}{// manual work for us. It returns:}
\PYG{+w}{    }\PYG{c+c1}{//   \PYGZhy{} A negative number (\PYGZlt{} 0) if word1 comes before word2.}
\PYG{+w}{    }\PYG{c+c1}{//   \PYGZhy{} A positive number (\PYGZgt{} 0) if word1 comes after word2.}
\PYG{+w}{    }\PYG{c+c1}{//   \PYGZhy{} Zero (0) if the strings are identical.}
\PYG{+w}{    }\PYG{k+kt}{int}\PYG{+w}{ }\PYG{n}{comparison\PYGZus{}result}\PYG{+w}{ }\PYG{o}{=}\PYG{+w}{ }\PYG{n}{strcmp}\PYG{p}{(}\PYG{n}{word1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word2}\PYG{p}{);}

\PYG{+w}{    }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZhy{}\PYGZhy{}\PYGZhy{} Result \PYGZhy{}\PYGZhy{}\PYGZhy{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{);}
\PYG{+w}{    }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{comparison\PYGZus{}result}\PYG{+w}{ }\PYG{o}{\PYGZlt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ comes before }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ alphabetically.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word2}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{k}{if}\PYG{+w}{ }\PYG{p}{(}\PYG{n}{comparison\PYGZus{}result}\PYG{+w}{ }\PYG{o}{\PYGZgt{}}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{)}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ comes after }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{ alphabetically.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word1}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word2}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}\PYG{+w}{ }\PYG{k}{else}\PYG{+w}{ }\PYG{p}{\PYGZob{}}
\PYG{+w}{        }\PYG{n}{printf}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}You entered the same word, }\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{\PYGZpc{}s}\PYG{l+s+se}{\PYGZbs{}\PYGZdq{}}\PYG{l+s}{, twice.}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}\PYG{+w}{ }\PYG{n}{word1}\PYG{p}{);}
\PYG{+w}{    }\PYG{p}{\PYGZcb{}}

\PYG{+w}{    }\PYG{k}{return}\PYG{+w}{ }\PYG{l+m+mi}{0}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}

\PYG{c+cm}{/*}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    Further Exploration:}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{    1.  `strcmp()` is case\PYGZhy{}sensitive. \PYGZsq{}A\PYGZsq{} comes before \PYGZsq{}a\PYGZsq{}. There is another}
\PYG{c+cm}{        function, often called `stricmp()` or `strcasecmp()`, that performs a}
\PYG{c+cm}{        case\PYGZhy{}insensitive comparison. Its availability can depend on the system,}
\PYG{c+cm}{        but it\PYGZsq{}s good to know it exists.}
\PYG{c+cm}{    2.  How would you sort an *array* of strings? You would need a sorting}
\PYG{c+cm}{        algorithm (like bubble sort, which we\PYGZsq{}ll see later) and you would use}
\PYG{c+cm}{        `strcmp()` for the comparisons. You would also need to swap the strings}
\PYG{c+cm}{        if they are out of order, which requires the `strcpy()` function. This}
\PYG{c+cm}{        is a classic, challenging C exercise!}
\PYG{c+cm}{    ================================================================================}
\PYG{c+cm}{*/}

\end{Verbatim}
